from typing import List


class Solution:
    def insideBoundary(self, x, y):
        if x >= 0 and x < self.m and y >= 0 and y < self.n:
            if self.grid[x][y] != '#':
                return True
        return False

    def reachableSide(self, px, py, bx, by):
        visited = [0] * 2500
        BFS_queue = []
        BFS_queue.append((px, py))
        visited[px * 50 + py] = 1
        r = [0, 0, 0, 0]
        possible_side_num = 0
        for i in range(4):
            nx = bx + self.dx[i]
            ny = by + self.dy[i]
            if self.insideBoundary(nx, ny):
                if (nx, ny) == (px, py):
                    r[i] = -1
                else:
                    r[i] = nx * 50 + ny + 1
                    possible_side_num += 1
        while BFS_queue:
            tt = BFS_queue.pop(0)
            for i in range(4):
                nx = tt[0] + self.dx[i]
                ny = tt[1] + self.dy[i]
                if self.insideBoundary(nx, ny):
                    if (nx, ny) != (bx, by):
                        t = nx * 50 + ny
                        if visited[t]:
                            continue
                        visited[t] = 1
                        for j in range(4):
                            if r[j] == t + 1:
                                r[j] = -1
                                possible_side_num -= 1
                                if possible_side_num <= 0:
                                    return r
                                break
                        BFS_queue.append((nx, ny))
        return r

    def minPushBox(self, grid: List[List[str]]) -> int:
        self.grid = grid
        visited = [[] for i in range(2500)]
        BFS_queue = []
        self.dx = [1, -1, 0, 0]
        self.dy = [0, 0, 1, -1]
        # get the init status
        self.m = len(grid)
        self.n = len(grid[0])
        for i in range(self.m):
            for j in range(self.n):
                if grid[i][j] == 'S':  # start pos
                    sx = i
                    sy = j
                elif grid[i][j] == 'B':  # box pos
                    bx = i
                    by = j
        start_status = (sx, sy, bx, by, 0)
        visited[sx * 50 + sy].append(bx * 50 + by + 1)
        BFS_queue.append(start_status)
        while BFS_queue:
            t = BFS_queue.pop(0)
            r = self.reachableSide(t[0], t[1], t[2], t[3])
            for i in range(4):
                if r[i] == -1:
                    nx = t[2]
                    ny = t[3]
                    bnx = t[2] - self.dx[i]
                    bny = t[3] - self.dy[i]
                    if self.insideBoundary(bnx, bny):
                        if grid[bnx][bny] == 'T':
                            return t[4] + 1
                        if bnx * 50 + bny + 1 in visited[nx * 50 + ny]:
                            continue
                        BFS_queue.append((nx, ny, bnx, bny, t[4] + 1))
                        visited[nx * 50 + ny].append(bnx * 50 + bny + 1)
        return -1


a = Solution()
print(a.minPushBox([["#", "#", "#", "#", "#", "#"],
                    ["#", "T", "#", "#", "#", "#"],
                    ["#", ".", ".", "B", ".", "#"],
                    ["#", ".", "#", "#", ".", "#"],
                    ["#", ".", ".", ".", "S", "#"],
                    ["#", "#", "#", "#", "#", "#"]]))
print(a.minPushBox([["#", "#", "#", "#", "#", "#"],
                    ["#", "T", "#", "#", "#", "#"],
                    ["#", ".", ".", "B", ".", "#"],
                    ["#", "#", "#", "#", ".", "#"],
                    ["#", ".", ".", ".", "S", "#"],
                    ["#", "#", "#", "#", "#", "#"]]))
print(a.minPushBox([["#", "#", "#", "#", "#", "#"],
                    ["#", "T", ".", ".", "#", "#"],
                    ["#", ".", "#", "B", ".", "#"],
                    ["#", ".", ".", ".", ".", "#"],
                    ["#", ".", ".", ".", "S", "#"],
                    ["#", "#", "#", "#", "#", "#"]]))
print(a.minPushBox([["#", "#", "#", "#", "#", "#", "#"],
                    ["#", "S", "#", ".", "B", "T", "#"],
                    ["#", "#", "#", "#", "#", "#", "#"]]))
print(a.minPushBox([[".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"],
                    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#"],
                    ["#", "#", ".", ".", "#", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", "#", "#", "#", ".", "B", ".", ".", ".", ".", "."],
                    [".", ".", "#", ".", ".", ".", "#", "#", "#", ".", ".", "."],
                    [".", "#", ".", ".", ".", ".", ".", ".", ".", "#", ".", "."],
                    [".", ".", ".", "S", "#", "#", "T", ".", ".", ".", "#", "."],
                    [".", ".", ".", ".", ".", ".", ".", ".", "#", ".", "#", "."],
                    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#", "."]]))

print(a.minPushBox([["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#", "#", "#", "#"],
                    ["#", ".", "#", "#", "#", "#", ".", "#", "#", "#", "#", ".", "#", "#", "#", "."],
                    ["#", ".", ".", ".", ".", ".", ".", "#", "T", "#", ".", ".", "#", "#", "#", "."],
                    ["#", ".", ".", ".", "#", ".", ".", ".", ".", ".", ".", ".", "#", "#", "#", "."],
                    ["#", ".", ".", ".", ".", ".", "B", ".", ".", ".", ".", ".", "#", "#", "#", "."],
                    ["#", ".", "#", "#", "#", "#", "#", "#", "#", "#", "#", ".", "#", "#", "#", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
                    ["#", ".", ".", ".", ".", ".", ".", ".", "S", ".", ".", ".", ".", ".", ".", "."],
                    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"]]))
print(a.minPushBox([["#", ".", ".", "#", "T", "#", "#", "#", "#"],
                    ["#", ".", ".", "#", ".", "#", ".", ".", "#"],
                    ["#", ".", ".", "#", ".", "#", "B", ".", "#"],
                    ["#", ".", ".", ".", ".", ".", ".", ".", "#"],
                    ["#", ".", ".", ".", ".", "#", ".", "S", "#"],
                    ["#", ".", ".", "#", ".", "#", "#", "#", "#"]]))
